# Проектная работа "Веб-ларёк"
Учебное SPA‑приложение «Веб-ларёк» для просмотра каталога цифровых товаров, управления корзиной и оформления заказа.

---

## Технологический стек
HTML, SCSS, TypeScript, Webpack

Архитектура: **MVP + EventBus**
- SOLID
- Чёткое разделение Model / View / Presenter
- SSOT — единый источник данных в моделях
- Pub/Sub — взаимодействие модулей через EventEmitter

---

## Структура проекта

```
src/
  components/
    appState/               # Состояние приложения
    base/                   # API и EventEmitter
    cart/                   # Компонент корзины
    order/                  # Компонент оформления заказа
    products/               # Компонент каталога товаров
    view/                   # Базовое отображение
    viewModal/              # Базовый класс для модальных окон

  types/
    components/             # Все интерфейсы приложения

  pages/
    index.html              # Страница

  utils/
    constants.ts            # Глобальные константы
    utils.ts                # Утилиты

docs/
    web-ларёк UML-схема.jpg 
    web-ларёк UML-схема.pdf 
    web-ларёк UML-схема.png 
```

---

## Архитектура

Основные слои:

| Слой | Ответственность |
|------|----------------|
| **Model** | Данные и бизнес‑логика |
| **View** | DOM, UI, события пользователя |
| **Presenter** | Управление логикой и навигацией между View и Model |
| **EventBus** | Связь компонентов без прямых зависимостей |

Взаимодействие:
```
Пользователь → View → Presenter → Model
Model → Presenter → View
Presenter → EventBus → Presenter
```

### SOLID и инверсия зависимостей

Приложение спроектировано согласно принципам **SOLID**:
- **S** — каждый модуль отвечает только за свою зону (Model/View/Presenter разделены)
- **O** — расширение без изменения существующего кода благодаря выделению интерфейсов
- **L** — строгая замена реализаций интерфейсов без изменения поведения
- **I** — интерфейсы разделены по функциональности (нет "толстых" контрактов)
- **D** — **Presenter** и другие слои зависят не от конкретных классов, а от **абстракций** (интерфейсов)

Взаимодействие модулей построено через `EventEmitter`, что исключает прямые зависимости между компонентами.
Интерфейсы размещены в `src/types` и гарантируют универсальные контракты между слоями.

---

## UML‑диаграмма
Основная схема архитектуры приложения:
![web-ларёк UML-схема.png](docs/web-%D0%BB%D0%B0%D1%80%D1%91%D0%BA%20UML-%D1%81%D1%85%D0%B5%D0%BC%D0%B0.png)
Более подробные версии доступны в каталоге:
```
docs/
    web-ларёк UML-схема.jpg # дополнительная версия
    web-ларёк UML-схема.pdf # схема без сжатия, для детального рассмотрения
    web-ларёк UML-схема.png # изображение для README
```
---

## Основные модули

Приложение состоит из трёх основных модулей моделей данных, которые отвечают за состояние и бизнес‑логику: каталог товаров, корзина и оформление заказа.

---

### `ModelProduct` — управление каталогом товаров

**Назначение:**
Хранение списка товаров и предоставление доступа к данным каталога.

**Функции:**
- хранение массива товаров
- возврат всех товаров или определённого по `id`
- получение количества товаров

**Основные методы:**
- `getProducts()`
- `getProductById(id)`
- `getProductsCount()`

---

### `ModelCart` — управление корзиной

**Назначение:**
Работа с выбранными пользователем товарами и итоговой стоимостью.

**Функции:**
- добавление и удаление товаров
- пересчёт суммы и количества
- сохранение состояния в `localStorage`
- очистка корзины перед оформлением заказа

**Основные методы:**
- `addItem(item)`
- `removeItem(itemId)`
- `clearCart()`
- `getItems()`
- `getTotalPrice()`
- `getItemsCount()`

---

### `ModelOrder` — оформление заказа

**Назначение:**
Хранение данных заказа и их валидация.

**Функции:**
- сохранение контактных данных
- выбор способа оплаты
- хранение итоговой суммы
- очистка данных после оформления

**Основные методы:**
- `setItems(items)`
- `setPaymentMethod(method)`
- `setEmail(email)`
- `setPhone(phone)`
- `setAddress(address)`
- `clearData()`
- `getOrderData()`

---

Типы данных для всех моделей и интерфейсов находятся в каталоге `src/types`.

---

## Представления (View)

Слой представлений отвечает за работу с DOM, отображение данных и проброс пользовательских действий во внешний слой (Presenter). View не содержит бизнес‑логики и не изменяет модели напрямую.

---

### `ViewProductList` — список товаров каталога

**Назначение:**
Отображение списка товаров и делегирование кликов по карточкам.

**Функции:**
- создание и отрисовка карточек каталога на основе HTML‑шаблона `#card-catalog`
- отображение категории, названия, цены и изображения
- проброс id товара по клику на `.card`

**Основные методы:**
- `update(products: IProduct[])` — рендер каталога
- `setOnProductClickCallback(cb)` — обработка кликов по товарам

---

### `ViewProductModal` — модальное окно товара

**Назначение:**
Показ деталей товара и добавление его в корзину.

**Функции:**
- отображение описания, цены, изображения
- управление состоянием кнопки «Купить» в зависимости от доступности товара
- проброс события добавления в корзину

**Основные методы:**
- `update(product: IProduct)` — рендер карточки товара в модалке
- `setOnAddToCartCallback(cb)` — обработка события покупки
- `setInCartState(inCart: boolean)` — переключение состояния кнопки

---

### `ViewCartModal` — модальное окно корзины

**Назначение:**
Отображение содержимого корзины, возможности удаления товаров и перехода к оформлению заказа.

**Функции:**
- отображение списка товаров и итоговой суммы
- синхронизация счётчика товаров в шапке
- проброс действий удаления товара и оформления заказа

**Основные методы:**
- `update(cartData: ICart)` — актуализация содержимого корзины
- `setOnRemoveToCartCallback(cb)` — удаление товара
- `setOnOrderCallback(cb)` — начало оформления заказа

---

### `ViewOrderModal` — модальное окно оформления заказа

**Назначение:**
Пошаговое оформление заказа с валидацией данных.

**Функции:**
- ввод данных доставки и контактов
- валидация email/телефона по RegExp
- отображение успешного и неуспешного результата

**Основные методы:**
- `setStep(step)` — навигация между шагами
- `setDataStep1Callback(cb)` — шаг 1 (оплата + адрес)
- `setDataStep2Callback(cb)` — шаг 2 (email + телефон)
- `setDataStep3Callback(cb)` — шаг 3 (успешное завершение)
- `setOrderResult(id, total)` — отображение номера заказа
- `setOrderError(msg)` — отображение текста ошибки

---

Базовые классы `View` и `ViewModal` обеспечивают обработку событий, рендер, монтирование и размонтирование DOM‑элементов.

---
## Базовые абстракции представлений

### `View<S>` — базовый класс представлений

Базовый класс для всех представлений, работающих с DOM.  
Обеспечивает создание корневого элемента, рендеринг, монтирование и управление событиями.

- `root` — корневой DOM-элемент представления
- `state` — состояние представления типа `S`
- `render()` — метод рендеринга, который должен быть реализован в наследниках
- `mount(parent: HTMLElement)` — добавляет `root` в DOM
- `unmount()` — удаляет `root` из DOM
- `on(event: string, handler: EventListener)` — добавляет обработчик события на `root`
- `off(event: string, handler: EventListener)` — удаляет обработчик события с `root`

### `ViewModal<S>` — базовый класс для модальных окон

Наследуется от `View<S>`.  
Добавляет функциональность открытия и закрытия модального окна.

- `open()` — открывает модальное окно (добавляет в DOM, показывает)
- `close()` — закрывает модальное окно (прячет, удаляет из DOM)
- Обработка клика по фону и кнопке закрытия для закрытия окна
- Поддержка анимаций открытия/закрытия

Эти базовые классы упрощают создание новых представлений и модальных окон, обеспечивая единый интерфейс и управление жизненным циклом компонентов.

---

## Презентеры (Presenter)

Презентеры управляют бизнес‑логикой, взаимодействуют с моделями и обновляют View.  
Связь между модулями происходит через централизованный `EventBus`, что исключает прямые зависимости.

---

### `PresenterProductList` — каталог товаров

**Назначение:**
Связь модели каталога (`ModelProduct`) и списка товаров (`ViewProductList`).

**Функции:**
- получение данных каталога из модели
- отображение каталога
- проброс кликов по товарам в виде событий

**Основные события и действия:**
- слушает `PRODUCT_EVENTS.PRODUCTS_LOADED` → обновляет view
- `onProductClick(productId)` → получает товар и эмитит `PRODUCT_EVENTS.PRODUCT_CLICK`

---

### `PresenterProductModal` — модальное окно товара

**Назначение:**
Показ деталей товара, проверка наличия в корзине, добавление в корзину.

**Функции:**
- открытие модального окна товара по событию `PRODUCT_EVENTS.PRODUCT_CLICK`
- асинхронная проверка, находится ли товар в корзине
- добавление товара в корзину через `CART_EVENTS.CART_PRODUCT_ADD`
- закрытие модального окна после добавления товара

---

### `PresenterCart` — модальное окно корзины

**Назначение:**
Связь модели корзины (`ModelCart`), модального окна корзины (`ViewCartModal`) и других модулей.

**Функции:**
- управление открытием/закрытием модального окна корзины
- добавление/удаление товаров
- пересчёт итогов и синхронизация view
- начало оформления заказа

**Основные события:**
- слушает `CART_EVENTS.CART_PRODUCT_ADD` → обновляет корзину
- эмитит `CART_EVENTS.CART_COMPLETE` при переходе к оформлению заказа
- обрабатывает запрос `CART_EVENTS.CART_CHECK_ITEM` → отвечает, есть ли товар в корзине

---

### `PresenterOrder` — модальное окно оформления заказа

**Назначение:**
Пошаговый процесс оформления заказа и интеграция с серверным API.

**Функции:**
- заполнение данных заказа из корзины
- валидация контактных данных
- отправка заказа на сервер и отображение результата

**Основные события:**
- слушает `CART_EVENTS.CART_COMPLETE` → открывает модальное окно оформления
- эмитит `ORDER_EVENTS.ORDER_SUBMIT` при успешном заказе

---

## Взаимодействие между Model, View, Presenter

Общий принцип:
```
Пользователь → View → Presenter → Model
Model → Presenter → View
Presenter → EventBus → Presenter
```

### Основные потоки данных:

1. **Клик по товару**
   - ViewProductList → PresenterProductList → PRODUCT_CLICK → PresenterProductModal → ModelProduct → ViewProductModal

2. **Добавление товара**
   - ViewProductModal → PresenterProductModal → CART_PRODUCT_ADD → PresenterCart → ModelCart → ViewCartModal

3. **Оформление заказа**
   - ViewCartModal → PresenterCart → CART_COMPLETE → PresenterOrder → ModelOrder → ViewOrderModal → API → PresenterOrder → ViewOrderModal

---

## AppState — инициализация данных и состояние модальных окон

`AppState` — класс-координатор, который реализует интерфейс `IAppState` и отвечает за начальную загрузку данных и восстановление состояния корзины.  
Он **не работает с DOM** и **не создаёт View**, а только взаимодействует с моделями и EventBus.

### Зависимости конструктора:

- `modelProduct: IModelProduct` — модель каталога товаров
- `modelCart: IModelCart` — модель корзины
- `modelOrder: IModelOrder` — модель заказа (резерв под развитие)
- `events: IEvents` — шина событий приложения
- `productApi: IProductApi` — API-клиент загрузки товаров

---
### Роль в архитектуре

- запускает приложение (данные готовы → события отправлены)
- восстанавливает состояние корзины при старте страницы
- хранит и контролирует информацию о том, какая модалка открыта, реагируя на `SYSTEM_EVENTS.MODAL_OPEN` и `SYSTEM_EVENTS.MODAL_CLOSE`

---

## EventBus — коммуникация между частями приложения

`EventBus` — это централизованный механизм событий, реализованный через `EventEmitter` или аналог, который обеспечивает обмен сообщениями между модулями без прямых зависимостей.

Основные характеристики:
- Подписка на события и их обработка
- Эмитирование событий с передачей данных
- Обеспечение слабой связанности между компонентами
- Поддержка различных типов событий (например, `PRODUCT_EVENTS`, `CART_EVENTS`, `ORDER_EVENTS`)

Использование `EventBus` способствует чистой архитектуре и упрощает расширение приложения.

---

## API‑клиенты

Для работы с сервером используется базовый абстрактный класс `Api`, обеспечивающий выполнение HTTP‑запросов и обработку ошибок.  
Конкретные реализации (`ProductApi`, `OrderApi`) формируют строго типизированные запросы на основе интерфейсов данных.

### Базовый класс `Api`

**Основные методы:**

| Метод | Назначение |
|-------|------------|
| `protected async get<T>(uri: string): Promise<T>` | Выполняет GET‑запрос и возвращает данные требуемого типа |
| `protected async post<T, B>(uri: string, body: B): Promise<T>` | Выполняет POST‑запрос с телом `body` и возвращает результат |
| `protected handleResponse<T>(response: Response): Promise<T>` | Единая обработка статуса и JSON‑ответа сервера |

Класс `Api` скрывает детали `fetch` и единую обработку ошибок, что упрощает поддержку.

---

### `ProductApi` — загрузка каталога товаров

**Назначение:** получение данных каталога с сервера.

**Публичные методы API:**

| Метод | Возвращаемые данные | Используется |
|-------|--------------------|--------------|
| `getProducts(): Promise<IProduct[]>` | список товаров | `AppState.init()` при старте приложения |

Запросы:

```
GET /product
Response: IProduct[]
```

---

### `OrderApi` — создание заказа

**Назначение:** создание заказа на сервере.

**Публичные методы API:**

| Метод | Аргументы | Возвращаемые данные | Используется |
|-------|-----------|------------------|--------------|
| `postOrder(order: IOrder): Promise<{ id: string, total: number }>` | данные заказа | номер заказа + итоговая сумма | на шаге оплаты в `PresenterOrder` |

Запросы:

```
POST /order
Body: IOrder
Response: { id: string, total: number }
```

---

Компоненты приложения не работают напрямую с `fetch` — только через типизированные методы API‑клиентов, благодаря чему бизнес‑логика остаётся изолированной от сетевого слоя.

---

## Типы данных

Ключевые интерфейсы расположены в `src/types/components/...`

Примеры:
- `IProduct`, `IModelProduct`, `IViewProductModal`, `IViewProductList`
- `ICart`, `IModelCart`, `IViewCartModal`
- `IOrder`, `IModelOrder`, `IViewOrderModal`
- `IProductApi`, `IOrderApi`
- `IViewModal`, `IViewCartModal`

## Установка и запуск

```sh
npm install
npm run start
```

или

```sh
yarn
yarn start
```

---

## Сборка

```sh
npm run build
```

или

```sh
yarn build
```

---