# Проектная работа "Веб-ларёк"
Учебное SPA‑приложение «Веб-ларёк» для просмотра каталога цифровых товаров, управления корзиной и оформления заказа.

---

## Технологический стек
HTML, SCSS, TypeScript, Webpack

Архитектура: **MVP + EventBus**
- SOLID
- Чёткое разделение Model / View / Presenter
- SSOT — единый источник данных в моделях
- Pub/Sub — взаимодействие модулей через EventEmitter

---

## Структура проекта

```
src/
  components/
    appState/               # Состояние приложения
    base/                   # API и EventEmitter
    cart/                   # Компонент корзины
    order/                  # Компонент оформления заказа
    products/               # Компонент каталога товаров
    view/                   # Базовое отображение
    viewModal/              # Базовый класс для модальных окон

  types/
    components/             # Все интерфейсы приложения

  pages/
    index.html              # Страница

  utils/
    constants.ts            # Глобальные константы
    utils.ts                # Утилиты

docs/
    web-ларёк UML-схема.jpg 
    web-ларёк UML-схема.pdf 
    web-ларёк UML-схема.png 
```

---

## Архитектура

Основные слои:

| Слой | Ответственность |
|------|----------------|
| **Model** | Данные и бизнес‑логика |
| **View** | DOM, UI, события пользователя |
| **Presenter** | Управление логикой и навигацией между View и Model |
| **EventBus** | Связь компонентов без прямых зависимостей |

Взаимодействие:
```
Пользователь → View → Presenter → Model
Model → Presenter → View
Presenter → EventBus → Presenter
```

### SOLID и инверсия зависимостей

Приложение спроектировано согласно принципам **SOLID**:
- **S** — каждый модуль отвечает только за свою зону (Model/View/Presenter разделены)
- **O** — расширение без изменения существующего кода благодаря выделению интерфейсов
- **L** — строгая замена реализаций интерфейсов без изменения поведения
- **I** — интерфейсы разделены по функциональности (нет "толстых" контрактов)
- **D** — **Presenter** и другие слои зависят не от конкретных классов, а от **абстракций** (интерфейсов)

Взаимодействие модулей построено через `EventEmitter`, что исключает прямые зависимости между компонентами.
Интерфейсы размещены в `src/types` и гарантируют универсальные контракты между слоями.

---

## UML‑диаграмма
Основная схема архитектуры приложения:
![web-ларёк UML-схема.png](docs/web-%D0%BB%D0%B0%D1%80%D1%91%D0%BA%20UML-%D1%81%D1%85%D0%B5%D0%BC%D0%B0.png)
Более подробные версии доступны в каталоге:
```
docs/
    web-ларёк UML-схема.jpg # дополнительная версия
    web-ларёк UML-схема.pdf # схема без сжатия, для детального рассмотрения
    web-ларёк UML-схема.png # изображение для README
```
---

## Основные модули

Приложение состоит из трёх основных модулей моделей данных, которые отвечают за состояние и бизнес‑логику: каталог товаров, корзина и оформление заказа.

---

### `ModelProduct` — управление каталогом товаров

**Назначение:**
Хранение списка товаров и предоставление доступа к данным каталога.

**Функции:**
- хранение массива товаров
- возврат всех товаров или определённого по `id`
- получение количества товаров

**Основные методы:**
- `getProducts()`
- `getProductById(id)`
- `getProductsCount()`

---

### `ModelCart` — управление корзиной

**Назначение:**
Работа с выбранными пользователем товарами и итоговой стоимостью.

**Функции:**
- добавление и удаление товаров
- пересчёт суммы и количества
- сохранение состояния в `localStorage`
- очистка корзины перед оформлением заказа

**Основные методы:**
- `init(cartData: ICart)` — инициализация корзины из сохранённых данных
- `addItem(item: IProduct)` — добавление товара в корзину
- `removeItem(itemId: string)` — удаление товара из корзины
- `clearCart()` — очистка корзины
- `getItems(): IProduct[]` — получение списка товаров
- `getTotalPrice(): number` — получение итоговой суммы
- `getItemsCount(): number` — получение количества товаров
- `getItemById(id: string): IProduct | null` — получение товара по ID
- `getCartData(): ICart` — получение полных данных корзины

---

### `ModelOrder` — оформление заказа

**Назначение:**
Хранение данных заказа и их валидация.

**Функции:**
- сохранение контактных данных
- выбор способа оплаты
- хранение итоговой суммы
- очистка данных после оформления

**Основные методы:**
- `setItems(items: string[])` — установка списка ID товаров
- `setPaymentMethod(method: PaymentMethod)` — установка способа оплаты
- `setEmail(email: string)` — установка email с валидацией
- `setPhone(phone: string)` — установка телефона с валидацией
- `setAddress(address: string)` — установка адреса доставки
- `setTotal(total: number)` — установка итоговой суммы заказа
- `clearData()` — очистка данных заказа
- `getOrderData(): IOrder` — получение полных данных заказа

---

Типы данных для всех моделей и интерфейсов находятся в каталоге `src/types`.

---

## Представления (View)

Слой представлений отвечает за работу с DOM, отображение данных и проброс пользовательских действий во внешний слой (Presenter). View не содержит бизнес‑логики и не изменяет модели напрямую.

---

### `ViewProductList` — список товаров каталога

**Назначение:**
Отображение списка товаров и делегирование кликов по карточкам.

**Функции:**
- создание и отрисовка карточек каталога на основе HTML‑шаблона `#card-catalog`
- отображение категории, названия, цены и изображения
- проброс id товара по клику на `.card`

**Основные методы:**
- `update(products: IProduct[])` — рендер каталога
- `setOnProductClickCallback(cb)` — обработка кликов по товарам

---

### `ViewProductModal` — модальное окно товара

**Назначение:**
Показ деталей товара и добавление его в корзину.

**Функции:**
- отображение описания, цены, изображения
- управление состоянием кнопки «Купить» в зависимости от доступности товара
- проброс события добавления в корзину

**Основные методы:**
- `update(product: IProduct)` — рендер карточки товара в модалке
- `setOnAddToCartCallback(cb)` — обработка события покупки
- `setInCartState(inCart: boolean)` — переключение состояния кнопки

---

### `ViewCartModal` — модальное окно корзины

**Назначение:**
Отображение содержимого корзины, возможности удаления товаров и перехода к оформлению заказа.

**Функции:**
- отображение списка товаров и итоговой суммы
- синхронизация счётчика товаров в шапке
- проброс действий удаления товара и оформления заказа

**Основные методы:**
- `update(cartData: ICart)` — актуализация содержимого корзины
- `setOnRemoveToCartCallback(cb)` — удаление товара
- `setOnOrderCallback(cb)` — начало оформления заказа

---

### `ViewOrderModal` — модальное окно оформления заказа

**Назначение:**
Пошаговое оформление заказа с валидацией данных.

**Функции:**
- ввод данных доставки и контактов
- валидация email/телефона по RegExp
- отображение успешного и неуспешного результата

**Основные методы:**
- `setStep(step: OrderStep)` — навигация между шагами (1, 2, 3, 4)
- `setDataStep1Callback(cb)` — шаг 1 (оплата + адрес)
- `setDataStep2Callback(cb)` — шаг 2 (email + телефон)
- `setDataStep3Callback(cb)` — шаг 3 (успешное завершение)
- `setStep2Loading(isLoading: boolean)` — управление состоянием загрузки кнопки на шаге 2
- `setOrderResult(id: string, total: number)` — отображение номера заказа на шаге 3
- `setOrderError(msg: string)` — отображение текста ошибки на шаге 4

---

Базовые классы `View` и `ViewModal` обеспечивают обработку событий, рендер, монтирование и размонтирование DOM‑элементов.

---
## Базовые абстракции представлений

### `View<S>` — базовый класс представлений

Базовый класс для всех представлений, работающих с DOM.  
Обеспечивает создание корневого элемента, рендеринг, монтирование и управление состоянием.

- `el` — корневой DOM-элемент представления (protected)
- `state` — состояние представления типа `S` (protected)
- `isMounted` — флаг монтирования компонента (protected)
- `render()` — абстрактный метод рендеринга, который должен быть реализован в наследниках
- `mount()` — монтирует компонент в DOM (вызывает `render()`)
- `unmount()` — демонтирует компонент из DOM (очищает содержимое)
- `update(newState: Partial<S>)` — обновляет состояние и перерисовывает компонент, если он смонтирован
- `getElement(): HTMLElement | null` — возвращает корневой DOM-элемент

### `ViewModal<S>` — базовый класс для модальных окон

Наследуется от `View<S>`.  
Добавляет функциональность открытия и закрытия модального окна.

- `openModal()` — открывает модальное окно (блокирует прокрутку страницы, добавляет в DOM, показывает)
- `closeModal()` — закрывает модальное окно (восстанавливает прокрутку, прячет, удаляет из DOM)
- `setOnOpenModalCallback(callback)` — задаёт функцию-коллбек на открытие модального окна
- `setOnCloseModalCallback(callback)` — задаёт функцию-коллбек на закрытие модального окна
- Обработка клика по фону и кнопке закрытия для закрытия окна
- Обработка нажатия клавиши Escape для закрытия окна
- Поддержка анимаций открытия/закрытия

Эти базовые классы упрощают создание новых представлений и модальных окон, обеспечивая единый интерфейс и управление жизненным циклом компонентов.

---

## Презентеры (Presenter)

Презентеры управляют бизнес‑логикой, взаимодействуют с моделями и обновляют View.  
Связь между модулями происходит через централизованный `EventBus`, что исключает прямые зависимости.

---

### `PresenterProductList` — каталог товаров

**Назначение:**
Связь модели каталога (`ModelProduct`) и списка товаров (`ViewProductList`).

**Функции:**
- получение данных каталога из модели
- отображение каталога
- проброс кликов по товарам в виде событий

**Основные события и действия:**
- слушает `PRODUCT_EVENTS.PRODUCTS_LOADED` → получает товары из модели и обновляет view
- `onProductClick(productId)` → получает товар из модели по ID и эмитит `PRODUCT_EVENTS.PRODUCT_CLICK` с данными товара

---

### `PresenterProductModal` — модальное окно товара

**Назначение:**
Показ деталей товара, проверка наличия в корзине, добавление в корзину.

**Функции:**
- открытие модального окна товара по событию `PRODUCT_EVENTS.PRODUCT_CLICK`
- асинхронная проверка, находится ли товар в корзине
- добавление товара в корзину через `CART_EVENTS.CART_PRODUCT_ADD`
- закрытие модального окна после добавления товара

---

### `PresenterCart` — модальное окно корзины

**Назначение:**
Связь модели корзины (`ModelCart`), модального окна корзины (`ViewCartModal`) и других модулей.

**Функции:**
- управление открытием/закрытием модального окна корзины
- добавление/удаление товаров
- пересчёт итогов и синхронизация view
- начало оформления заказа

**Основные события:**
- слушает `CART_EVENTS.CART_LOADED` → обновляет view корзины после восстановления из localStorage
- слушает `CART_EVENTS.CART_PRODUCT_ADD` → добавляет товар в модель и обновляет view корзины
- слушает `CART_EVENTS.CART_PRODUCT_DELETE` → обновляет view корзины после удаления товара
- слушает `CART_EVENTS.CART_CHECK_ITEM` → отвечает, есть ли товар в корзине (используется `PresenterProductModal` для проверки наличия товара)
- эмитит `CART_EVENTS.CART_COMPLETE` при переходе к оформлению заказа (передаёт данные корзины)

---

### `PresenterOrder` — модальное окно оформления заказа

**Назначение:**
Пошаговый процесс оформления заказа и интеграция с серверным API.

**Функции:**
- заполнение данных заказа из корзины
- валидация контактных данных
- отправка заказа на сервер и отображение результата

**Основные события:**
- слушает `CART_EVENTS.CART_COMPLETE` → получает данные корзины, заполняет модель заказа и открывает модальное окно оформления
- эмитит `ORDER_EVENTS.ORDER_SUBMIT` при успешном заказе (после получения ответа от сервера и на шаге 3)
- эмитит `ORDER_EVENTS.ORDER_STEP` при смене шага оформления заказа

---

## Взаимодействие между Model, View, Presenter

Общий принцип:
```
Пользователь → View → Presenter → Model
Model → Presenter → View
Presenter → EventBus → Presenter
```

### Основные потоки данных:

1. **Клик по товару**
   - ViewProductList → PresenterProductList → PRODUCT_CLICK → PresenterProductModal → ModelProduct → ViewProductModal

2. **Добавление товара**
   - ViewProductModal → PresenterProductModal → CART_PRODUCT_ADD → PresenterCart → ModelCart → ViewCartModal

3. **Оформление заказа**
   - ViewCartModal → PresenterCart → CART_COMPLETE → PresenterOrder → ModelOrder → ViewOrderModal → API → PresenterOrder → ViewOrderModal

---

## AppState — инициализация данных и состояние модальных окон

`AppState` — класс-координатор, который реализует интерфейс `IAppState` и отвечает за начальную загрузку данных и восстановление состояния корзины.  
Он **не работает с DOM** и **не создаёт View**, а только взаимодействует с моделями и EventBus.

### Зависимости конструктора:

- `modelProduct: IModelProduct` — модель каталога товаров
- `modelCart: IModelCart` — модель корзины
- `modelOrder: IModelOrder` — модель заказа (резерв под развитие)
- `events: IEvents` — шина событий приложения
- `productApi: IProductApi` — API-клиент загрузки товаров

---
### Роль в архитектуре

- запускает приложение: загружает товары через API, восстанавливает корзину из localStorage
- загружает товары через `productApi.getProducts()` и эмитит `PRODUCT_EVENTS.PRODUCTS_LOADED` или `PRODUCT_EVENTS.PRODUCTS_LOAD_FAILED`
- восстанавливает состояние корзины из localStorage при старте страницы и эмитит `CART_EVENTS.CART_LOADED`
- хранит и контролирует информацию о том, какая модалка открыта, реагируя на `SYSTEM_EVENTS.MODAL_OPEN` и `SYSTEM_EVENTS.MODAL_CLOSE`

---

## EventBus — коммуникация между частями приложения

`EventBus` — это централизованный механизм событий, реализованный через `EventEmitter` или аналог, который обеспечивает обмен сообщениями между модулями без прямых зависимостей.

Основные характеристики:
- Подписка на события через `on<T>(event, callback)` и их обработка
- Эмитирование событий с передачей данных через `emit<T>(event, data?)`
- Отписка от событий через `off(event, callback)`
- Обеспечение слабой связанности между компонентами
- Поддержка различных типов событий: `PRODUCT_EVENTS`, `CART_EVENTS`, `ORDER_EVENTS`, `SYSTEM_EVENTS`
- Поддержка подписки на все события через `onAll(callback)`
- Создание триггеров через `trigger(eventName, context?)`

Реализован через класс `EventEmitter`, который реализует интерфейс `IEvents`. Использование `EventBus` способствует чистой архитектуре и упрощает расширение приложения.

---

## API‑клиенты

Для работы с сервером используется базовый абстрактный класс `Api`, обеспечивающий выполнение HTTP‑запросов и обработку ошибок.  
Конкретные реализации (`ProductApi`, `OrderApi`) формируют строго типизированные запросы на основе интерфейсов данных.

### Базовый класс `Api`

**Основные методы:**

| Метод | Назначение |
|-------|------------|
| `public get<T>(uri: string): Promise<T>` | Выполняет GET‑запрос и возвращает данные требуемого типа |
| `public post<T>(uri: string, data: object, method?: ApiPostMethods): Promise<T>` | Выполняет POST/PUT/DELETE‑запрос с телом `data` и возвращает результат |
| `protected handleResponse<T>(response: Response): Promise<T>` | Единая обработка статуса и JSON‑ответа сервера |

Класс `Api` скрывает детали `fetch` и единую обработку ошибок, что упрощает поддержку.

---

### `ProductApi` — загрузка каталога товаров

**Назначение:** получение данных каталога с сервера.

**Публичные методы API:**

| Метод | Возвращаемые данные | Используется |
|-------|--------------------|--------------|
| `getProducts(): Promise<IProduct[]>` | список товаров | `AppState.init()` при старте приложения |
| `getProductById(id: string): Promise<IProduct>` | данные товара по ID | резерв для будущего функционала |

Запросы:

```
GET /product
Response: ApiListResponse<IProduct> (содержит items: IProduct[])

GET /product/{id}
Response: IProduct
```

---

### `OrderApi` — создание заказа

**Назначение:** создание заказа на сервере.

**Публичные методы API:**

| Метод | Аргументы | Возвращаемые данные | Используется |
|-------|-----------|------------------|--------------|
| `postOrder(order: IOrder): Promise<{ id: string, total: number }>` | данные заказа | номер заказа + итоговая сумма | на шаге оплаты в `PresenterOrder` |

Запросы:

```
POST /order
Body: IOrder
Response: { id: string, total: number }
```

---

Компоненты приложения не работают напрямую с `fetch` — только через типизированные методы API‑клиентов, благодаря чему бизнес‑логика остаётся изолированной от сетевого слоя.

---

## Типы данных

Ключевые интерфейсы расположены в `src/types/components/...`

Примеры:
- `IProduct`, `IModelProduct`, `IViewProductModal`, `IViewProductList`
- `ICart`, `IModelCart`, `IViewCartModal`
- `IOrder`, `IModelOrder`, `IViewOrderModal`
- `IProductApi`, `IOrderApi`
- `IViewModal`, `IViewCartModal`

## Установка и запуск

```sh
npm install
npm run start
```

или

```sh
yarn
yarn start
```

---

## Сборка

```sh
npm run build
```

или

```sh
yarn build
```

---